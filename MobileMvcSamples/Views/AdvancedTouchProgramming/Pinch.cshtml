@{
    Layout = null;
}

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />
    <title>Pinch</title>

  <style>
    #the-box {
      background-color: red;
      height: 200px;
      margin: 20px 0 0 20px;
      width: 200px;
      position: absolute;
    }
  </style>
</head>
<body>
  <h1>Pinch</h1>

  <div id="the-box">

  </div>

  <script>
    window.addEventListener('load', load);

    //var box, moveStarted, resizeStarted, offset, originalDistance, transformValue;

    function load() {
      var box = document.getElementById('the-box');

      //box.addEventListener('touchstart', start);
      //box.addEventListener('touchmove', move);
      //box.addEventListener('touchend', end);

      var pincher = new window.Pincher(box);
    }

    function start(evt) {
      //evt.preventDefault();
      //console.log('start', evt.touches.length);

      //if (evt.touches.length === 1)
      //  moveStarted = true;
      //else {
      //  resizeStarted = true;
      //  moveStarted = false; //If two touches, resizing
      //}

    }

    function move(evt) {
      if (moveStarted) {

        //if (!offset) {
        //  offset = getPosition(evt);
        //  console.log('new offset', offset.x, offset.y);
        //}
        //box.style.left = (evt.touches[0].pageX - offset.x) + 'px';
        //box.style.top = (evt.touches[0].pageY - offset.y) +  'px';
      }
      else if (resizeStarted && evt.touches.length > 1) {
        //if (!originalDistance) {
        //  var firstLength = Math.abs(evt.touches[0].pageX - evt.touches[1].pageX);
        //  var secondLength = Math.abs(evt.touches[0].pageY - evt.touches[1].pageY);

        //  originalDistance = Math.sqrt((firstLength * firstLength) + (secondLength * secondLength));

        //  console.log('calcing', originalDistance);
        //}
        //else {
        //  var firstLength = Math.abs(evt.touches[0].pageX - evt.touches[1].pageX);
        //  var secondLength = Math.abs(evt.touches[0].pageY - evt.touches[1].pageY);

        //  var newDistance = Math.sqrt((firstLength * firstLength) + (secondLength * secondLength));
        //  transformValue = newDistance / originalDistance;
        //  if (box.transformValue) {
        //    console.log('new value', transformValue, box.transformValue);
        //    transformValue = box.transformValue * transformValue;
        //  }

        //  box.style.webkitTransform = 'scale(' + transformValue + ')';
        //}
      }
    }

    function end(evt) {
      if (evt.touches.length < 2) {
        //moveStarted = false;
        offset = null;
        originalDistance = null;

        if (transformValue) {
          box.transformValue = transformValue;
          transformValue = null;
          //console.log('saving transform value', box.transformValue);
        }
      }
    }

    //function getPosition(evt) {

    //  var pageX, pageY;
    //  if (evt.touches) { //If this is a touch event
    //    pageX = evt.changedTouches[0].pageX;
    //    pageY = evt.changedTouches[0].pageY;
    //  }
    //  else { //If this is a mouse or pointer event
    //    pageX = evt.pageX;
    //    pageY = evt.pageY;
    //  }

    //  return {
    //    y: pageY - evt.target.offsetTop,
    //    x: pageX - evt.target.offsetLeft
    //  };
    //}

    //function getOffsets(element, offsets) {
    //  offsets = offsets || { left: element.offsetLeft, top: element.offsetTop };
    //  if (element.parentNode) {
    //    console.log('offset for parent', element.parentNode.offsetLeft, element.parentNode.offsetTop);
    //    offsets.left += element.parentNode.offsetLeft || 0;
    //    offsets.top += element.parentNode.offsetTop || 0;
    //    offsets = getOffsets(element.parentNode, offsets);
    //  }
    //  return offsets;
    //}

    window.Pincher = (function () {

      var pincher = function (element) {
        this.element = element;
        this.touches = {};
        this.touchCount = 0;
        this.mode = 'none'; //move, resize are other modes

        var self = this;

        this.element.addEventListener('touchstart', function (evt) { self.start.call(self, evt) });
        this.element.addEventListener('touchmove', function (evt) { self.change.call(self, evt) });
        this.element.addEventListener('touchend', function (evt) { self.end.call(self, evt) });
      }

      pincher.prototype.start = function (evt) {
        evt.preventDefault();
        this.registerTouch(evt);
        this.setMode();

        //console.log('this', this.mode, this);
        //console.log(evt);
      }

      pincher.prototype.change = function (evt) {

        if (this.mode === 'move') {
          //console.log('moving');
          this.move(evt);
        }
        else if (this.mode === 'resize') {
          //console.log('distance', this.originalDistanceBetweenTouchPoints);
          this.resize(evt);
        }

      }

      pincher.prototype.resize = function (evt) {
        if (!this.originalDistanceBetweenTouchPoints) {
          console.log('resetting originalDistanceBetweenTouchPoints');
          var firstLength = Math.abs(evt.touches[0].pageX - evt.touches[1].pageX);
          var secondLength = Math.abs(evt.touches[0].pageY - evt.touches[1].pageY);

          this.originalDistanceBetweenTouchPoints = Math.sqrt((firstLength * firstLength) + (secondLength * secondLength));

          //console.log('calcing', this.originalDistanceBetweenTouchPoints);
        }
        else {
          var firstLength = Math.abs(evt.touches[0].pageX - evt.touches[1].pageX);
          var secondLength = Math.abs(evt.touches[0].pageY - evt.touches[1].pageY);

          var newDistance = Math.sqrt((firstLength * firstLength) + (secondLength * secondLength));
          this.activeTransformValue = newDistance / this.originalDistanceBetweenTouchPoints;

          if (this.currentTransformValue) {
            this.activeTransformValue = this.currentTransformValue * this.activeTransformValue;
          }

          this.element.style.webkitTransform = 'scale(' + this.activeTransformValue + ')';
        }
      }

      pincher.prototype.move = function (evt) {
        if (!this.startingOffset)
          this.startingOffset = this.getPosition(evt);

        this.element.style.left = (evt.touches[0].pageX - this.startingOffset.x) + 'px';
        this.element.style.top = (evt.touches[0].pageY - this.startingOffset.y) + 'px';
      }

      pincher.prototype.end = function (evt) {

        //reset the events array. Avoids the lookup annoyance.
        this.touches = {};
        this.touchCount = 0;

        for (var i = 0; i < evt.touches.length; i++) {
          var touch = evt.touches[i];
          this.touches[touch.identifier] = touch;
          this.touchCount++;
        }

        //set state
        this.setMode();

        //After a resize finishes, we need to remember the transform value so we can start from there next time.
        if (this.activeTransformValue) {
          this.currentTransformValue = this.activeTransformValue;
        }

        if (this.touchCount < 2)
          this.originalDistanceBetweenTouchPoints = null;

      }

      pincher.prototype.registerTouch = function (evt) {
        if (evt.touches) {
          this.touchCount = 0;
          for (var i = 0; i < evt.touches.length; i++) {
            var touch = evt.touches[i];
            this.touches[touch.identifier] = touch;
            this.touchCount++;
          }
        }
      }

      pincher.prototype.setMode = function () {
        this.startingOffset = null;

        if (this.touchCount === 1)
          this.mode = 'move';
        else if (this.touchCount === 2)
          this.mode = 'resize';
        else
          this.mode = 'none';
      }

      pincher.prototype.getPosition = function(evt) {

        var pageX, pageY;
        if (evt.touches) { //If this is a touch event
          pageX = evt.changedTouches[0].pageX;
          pageY = evt.changedTouches[0].pageY;
        }
        else { //If this is a mouse or pointer event
          pageX = evt.pageX;
          pageY = evt.pageY;
        }

        return {
          y: pageY - evt.target.offsetTop,
          x: pageX - evt.target.offsetLeft
        };
      }


      return pincher;
    })();

    //console.log(window.Pincher);

    //PROBLEMS TO SOLVE

    //1. Multi-touch - normalize between approaches. Disparate touch collections
    //2. There are different modes. Handle this.



    //Notes
    //
    //1. To disable pinch and zoom for older Android, need to use viewport

  </script>

</body>
</html>
